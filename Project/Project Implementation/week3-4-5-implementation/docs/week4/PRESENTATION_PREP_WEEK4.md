# Week 4 Presentation Prep Guide

How to confidently present your user management system to peers and instructors.

---

## Presentation Overview (10-15 minutes)

### Suggested Structure

1. **Introduction** (1 min)
2. **Architecture Overview** (2 min)
3. **Live Demo** (5 min)
4. **Code Walkthrough** (5 min)
5. **Testing Showcase** (2 min)
6. **Q&A** (flexible)

---

## 1. Introduction (1 minute)

### What to Say

> "This week, I built a complete user management system for SAMS using Spring Boot. The system allows creating, reading, updating, and deleting users through a REST API. I implemented the industry-standard Repository-Service-Controller pattern and wrote comprehensive tests."

### Key Points to Mention
- âœ… Week 4 focus: CRUD operations for user management
- âœ… Technologies: Spring Boot, Spring Data JPA, PostgreSQL
- âœ… Patterns: Repository-Service-Controller, DTO pattern
- âœ… Testing: JUnit unit tests + Postman integration tests

---

## 2. Architecture Overview (2 minutes)

### Visual Aid - Draw This Diagram

```
Client (Postman)
     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONTROLLER    â”‚  UserController.java
â”‚  (REST API)    â”‚  - Handles HTTP requests
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  - Returns DTOs
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SERVICE      â”‚  UserService.java
â”‚ (Business Logic)â”‚ - Validates data
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ - Enforces rules
         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REPOSITORY    â”‚  UserRepository.java
â”‚ (Data Access)  â”‚  - Talks to database
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  - Spring auto-implements
         â†“
    Database
```

### What to Explain

**Controller Layer:**
> "This layer handles HTTP requests from clients like Postman or frontend apps. It receives JSON, calls the service layer, and returns responses. I implemented 7 endpoints for all CRUD operations."

**Service Layer:**
> "This is where business logic lives. It validates data, checks for duplicates, enforces rules like 'email must be unique', and coordinates repository calls. All the intelligence is here."

**Repository Layer:**
> "This layer talks directly to the database. The amazing thing is that Spring Data JPA automatically implements all the methods. I just write method names like `findByEmail`, and Spring generates the SQL."

**Why This Architecture?**
> "Each layer has one job. This makes the code easy to test, maintain, and understand. If I want to change how data is stored, I only touch the repository. If business rules change, I only touch the service."

---

## 3. Live Demo (5 minutes)

### Demo Script

**Open Postman and demonstrate:**

#### Demo Step 1: Create a User (POST)
**What to Say:**
> "Let me create a new student user. I'll send a POST request to `/api/users` with JSON containing username, email, password, and role."

**Show:**
- Request method: POST
- URL: `http://localhost:8080/api/users`
- Body:
```json
{
  "username": "demo_student",
  "email": "demo@student.com",
  "password": "password123",
  "role": "STUDENT"
}
```
- Click Send
- Point out: **201 Created** status code

**Explain Response:**
> "Notice the response includes an ID (generated by the database), but NOT the password. That's because we use DTOs to control what data is exposed."

---

#### Demo Step 2: Get All Users (GET)
**What to Say:**
> "Now let's retrieve all users with a GET request to `/api/users`."

**Show:**
- Request method: GET
- URL: `http://localhost:8080/api/users`
- Click Send
- Point out: **200 OK** status code and array of users

---

#### Demo Step 3: Update User (PUT)
**What to Say:**
> "I can update a user by sending a PUT request to `/api/users/{id}` with the new details."

**Show:**
- Request method: PUT
- URL: `http://localhost:8080/api/users/1`
- Body with updated username
- Click Send
- Show updated response

---

#### Demo Step 4: Get User by Role (GET)
**What to Say:**
> "The API supports filtering users by role. Let me get all students."

**Show:**
- Request method: GET
- URL: `http://localhost:8080/api/users/role/STUDENT`
- Show filtered results

---

#### Demo Step 5: Error Handling (POST)
**What to Say:**
> "Let's see what happens if I try to create a user with a duplicate email."

**Show:**
- Try to create user with existing email
- Point out: **400 Bad Request** status code
- Show error message: "Email already exists: demo@student.com"

**Explain:**
> "The system validates data and returns meaningful error messages. This is handled by the GlobalExceptionHandler I created."

---

## 4. Code Walkthrough (5 minutes)

### File 1: UserRepository.java

**Open the file and explain:**

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    List<User> findByRole(String role);
    boolean existsByEmail(String email);
}
```

**What to Say:**
> "This is just an interface, no implementation! Spring Data JPA automatically generates the SQL based on the method names. For example, `findByEmail` becomes a SELECT query with a WHERE clause on the email column. I get database operations without writing any SQL."

---

### File 2: UserService.java

**Open the file, focus on `createUser` method:**

```java
@Transactional
public User createUser(User user) {
    if (userRepository.existsByEmail(user.getEmail())) {
        throw new DuplicateEmailException(user.getEmail());
    }

    if (user.getRole() == null || user.getRole().isEmpty()) {
        user.setRole("STUDENT");
    }

    return userRepository.save(user);
}
```

**What to Say:**
> "This is where business logic lives. Before saving a user, I check if the email already exists and throw a custom exception if it does. I also set a default role if none is provided. The `@Transactional` annotation ensures that if anything fails, the database changes are rolled back."

**Why Constructor Injection:**
```java
private final UserRepository userRepository;

public UserService(UserRepository userRepository) {
    this.userRepository = userRepository;
}
```

> "I use constructor injection instead of @Autowired because it allows me to make the field `final`, which is safer. It also makes testing easier because I can pass in mock objects."

---

### File 3: UserController.java

**Open the file, focus on create and get endpoints:**

```java
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
public UserResponse createUser(@Valid @RequestBody UserRequest request) {
    User user = convertToEntity(request);
    User savedUser = userService.createUser(user);
    return convertToResponse(savedUser);
}
```

**What to Say:**
> "The controller is thinâ€”it doesn't contain business logic. It just receives requests, calls the service, and returns responses. I use `@Valid` to automatically validate the request body, and `@ResponseStatus` to return 201 Created. Notice I convert between entities and DTOs to control what data is exposed."

---

### File 4: GlobalExceptionHandler.java

**Open the file, show exception handler:**

```java
@ExceptionHandler(UserNotFoundException.class)
public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
    ErrorResponse error = new ErrorResponse(
        HttpStatus.NOT_FOUND.value(),
        ex.getMessage(),
        LocalDateTime.now()
    );
    return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
}
```

**What to Say:**
> "Instead of handling exceptions in every controller method, I created a global exception handler using `@ControllerAdvice`. When any controller throws a `UserNotFoundException`, this method catches it and returns a clean 404 error with a custom message. This keeps error handling consistent across the entire API."

---

## 5. Testing Showcase (2 minutes)

### Show Unit Tests

**Open UserServiceTest.java:**

```java
@Test
void testCreateUser_DuplicateEmail_ThrowsException() {
    // Arrange
    when(userRepository.existsByEmail("test@example.com")).thenReturn(true);

    // Act & Assert
    assertThrows(DuplicateEmailException.class, () -> {
        userService.createUser(testUser);
    });

    verify(userRepository, never()).save(any());
}
```

**What to Say:**
> "I wrote 8 unit tests covering both success and error scenarios. This test checks that creating a user with a duplicate email throws an exception. I use Mockito to mock the repository, so these tests don't touch the databaseâ€”they run in milliseconds. The `verify` call ensures that `save` was never called when validation fails."

**Run the tests:**
> "Let me run all tests... [Run tests in IDE] ... All 8 tests pass! This gives me confidence that my code works correctly."

---

### Show Postman Collection

**Open Postman:**

**What to Say:**
> "I also created a Postman collection with 13 requests covering all endpoints and error scenarios. This is useful for manual testing and can be shared with the team or used for API documentation."

---

## 6. Common Q&A Preparation

### Question 1: "Why do you need three layers?"

**Answer:**
> "Each layer has a specific job. The controller handles HTTP, the service handles business logic, and the repository handles data access. This separation makes code easier to test, maintain, and change. For example, if I want to switch from PostgreSQL to MongoDB, I only change the repository layer."

---

### Question 2: "How does Spring Data JPA generate implementations?"

**Answer:**
> "At runtime, Spring analyzes the method names in the repository interface. It parses names like `findByEmail` and generates the corresponding SQL query. This is called 'method name parsing'. Spring creates a proxy class that implements the interface with the generated queries."

---

### Question 3: "What's the point of DTOs?"

**Answer:**
> "DTOs control what data is exposed in the API. For example, my `User` entity has a password field, but the `UserResponse` DTO doesn't. This prevents accidentally sending sensitive data to clients. DTOs also allow the API structure to differ from the database structure."

---

### Question 4: "Why write unit tests?"

**Answer:**
> "Unit tests catch bugs early, before they reach users. They also give me confidence when changing codeâ€”if all tests still pass, I haven't broken anything. Plus, tests document how the code should behave. In a team setting, tests ensure everyone understands the expected behavior."

---

### Question 5: "What happens if I try to create a user with an invalid email?"

**Answer:**
> "The `@Valid` annotation on the request body triggers validation. If the email is invalid, Spring automatically returns a 400 Bad Request with detailed validation errors showing which fields failed. I don't have to write any code for thisâ€”it's built into Spring."

---

### Question 6: "How do you handle 'user not found' errors?"

**Answer:**
> "When the repository can't find a user, it returns an `Optional.empty()`. In the service layer, I use `.orElseThrow()` to convert this to a `UserNotFoundException`. The global exception handler catches this exception and returns a 404 Not Found response with a clear error message."

---

### Question 7: "What is @Transactional?"

**Answer:**
> "It wraps the method in a database transaction. If anything goes wrong during the method, all database changes are rolled back. This ensures data consistency. For example, if creating a user fails partway through, the database won't have incomplete data."

---

## Bonus: Advanced Questions

### Question: "How would you add pagination?"

**Answer:**
> "Spring Data JPA supports pagination out of the box. I would change the `findAll()` method to accept a `Pageable` parameter, and it would return a `Page<User>` with metadata like total pages, current page, etc."

---

### Question: "How would you add authentication?"

**Answer:**
> "That's planned for Week 5! I would use Spring Security with JWT tokens. Users would log in to receive a token, and all subsequent requests would include that token in the Authorization header. I'd add role-based access control so only admins can delete users."

---

### Question: "How do you handle concurrent updates?"

**Answer:**
> "Currently, the last write wins. To handle concurrency better, I could add an `@Version` field to the User entity. This enables optimistic lockingâ€”if two users try to update the same record simultaneously, one would get an error and need to retry."

---

## Presentation Tips

### Do's âœ…
- **Speak clearly and confidently**
- **Show the running application**
- **Explain the "why" not just the "what"**
- **Mention challenges you faced and how you solved them**
- **Use visual diagrams**

### Don'ts âŒ
- **Don't read code line by line**
- **Don't apologize for "simple" code**
- **Don't skip error handling demos**
- **Don't go too fast**
- **Don't assume everyone knows Spring Boot**

---

## Talking Points About Challenges

### Challenge 1: Understanding Optional
**What to Say:**
> "Initially, I was confused about `Optional<User>`. I learned that it forces you to handle the 'not found' case explicitly, preventing null pointer exceptions. Now I understand it's a best practice for methods that might not return a value."

### Challenge 2: Separation of Concerns
**What to Say:**
> "At first, I wanted to put all the logic in the controller because it seemed simpler. But I learned that separating business logic into the service layer makes the code much more testable and maintainable."

### Challenge 3: Mocking in Tests
**What to Say:**
> "Mockito was tricky at first. I didn't understand why I needed fake objects. Then I realized that unit tests should be isolatedâ€”they shouldn't depend on a database or network. Mocking lets me test just the service logic in isolation."

---

## Closing Statement

**What to Say:**
> "This week taught me how to build a professional-grade REST API with proper architecture. I now understand why layered design matters, how Spring Data JPA saves development time, and why testing is crucial. I'm ready to add more complex features like authentication and relationships between entities."

---

## Checklist Before Presentation

- âœ… Spring Boot application runs without errors
- âœ… Database is running and accessible
- âœ… Postman collection is loaded and organized
- âœ… All unit tests pass
- âœ… Example users created for demo
- âœ… Architecture diagram prepared
- âœ… Code files bookmarked for quick access
- âœ… Backup plan if demo fails (screenshots/video)

---

## Time Management

| Section | Time | Notes |
|---------|------|-------|
| Introduction | 1 min | Keep it brief |
| Architecture Overview | 2 min | Use diagram |
| Live Demo | 5 min | Practice beforehand |
| Code Walkthrough | 5 min | Focus on key files |
| Testing Showcase | 2 min | Run tests, show Postman |
| Q&A | Flexible | Be prepared |

**Total: ~15 minutes**

---

## Good Luck! ðŸŽ‰

You've built something real and professional. Be proud of your work and present with confidence!
